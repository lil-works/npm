<?php

namespace AppBundle\Entity;
use AppBundle\AppBundle;
use Doctrine\ORM\Query\ResultSetMapping;
/**
 * DescriptorRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class DescriptorRepository extends \Doctrine\ORM\EntityRepository
{
    public function findByLabelAndCategoryWithSynonym($label, $category)
    {
        $sql = "

       SELECT
       DISTINCT(id),
       label,
       (SELECT color from descriptor_category WHERE id = category) as color,
       category,count(DISTINCT(bd.breakdown_id)) as breakdownCount

        FROM (
                SELECT d.id as id , d.label as label , d.category as category , NULL as syn FROM descriptor d WHERE d.label LIKE :label
                UNION ALL
                SELECT s.descriptor as id, (SELECT label FROM descriptor WHERE id=s.descriptor) as label , (SELECT category FROM descriptor WHERE id=s.descriptor) as category , s.label as syn   FROM synonym s WHERE s.label LIKE :label
            ) tot
            LEFT JOIN
            breakdowns_descriptors as bd ON bd.descriptor_id=tot.id


            GROUP BY tot.id
            HAVING breakdownCount >= 0 AND category = :category
            ORDER BY breakdownCount DESC
        ";
        $em = $this->getEntityManager();
        $rsm = new ResultSetMapping;
        $rsm->addScalarResult('id', 'id');
        $rsm->addScalarResult('label', 'label');
        $rsm->addScalarResult('color', 'color');
        $query = $em->createNativeQuery($sql, $rsm);
        $query->setParameter('label', "$label");
        $query->setParameter('category', $category);
        return $query->getScalarResult();
    }

    public function findOneByLabelAndCategoryWithSynonym($label, $category)
    {

        $sql = "SELECT DISTINCT(id),label,category,count(DISTINCT(bd.breakdown_id)) as breakdownCount FROM (
                SELECT d.id as id , d.label as label , d.category as category , NULL as syn FROM descriptor d WHERE d.label LIKE :label
                UNION ALL
                SELECT s.descriptor as id, (SELECT label FROM descriptor WHERE id=s.descriptor) as label , (SELECT category FROM descriptor WHERE id=s.descriptor) as category , s.label as syn   FROM synonym s WHERE s.label LIKE :label
            ) tot
            LEFT JOIN
            breakdowns_descriptors as bd ON bd.descriptor_id=tot.id


            GROUP BY tot.id
            HAVING breakdownCount > 0 AND category = :category
            ORDER BY breakdownCount DESC
                ";


        $em = $this->getEntityManager();
        $rsm = new ResultSetMapping;
        $rsm->addScalarResult('id', 'id');
        $rsm->addScalarResult('label', 'label');
        $query = $em->createNativeQuery($sql, $rsm);
        $query->setParameter('label', "$label");
        $query->setParameter('category', $category);
        return $query->getScalarResult();
    }

    public function findOneByLabelAndCategory($label, $category)
    {

        $sql = "SELECT
                    *
                    FROM descriptor
                WHERE label LIKE :label AND category = $category

                ";


        $em = $this->getEntityManager();
        $rsm = new ResultSetMapping;
        $rsm->addScalarResult('id', 'id');
        $rsm->addScalarResult('label', 'label');
        $rsm->addScalarResult('color', 'color');
        $query = $em->createNativeQuery($sql, $rsm);
        $query->setParameter('label', "$label");
        $query->setParameter('category', $category);
        return $query->getScalarResult();
    }

    public function AnalyzerEdges($category, $start = null, $stop = null, $minDuration = null, $maxDuration = null)
    {

        $categoryIn = array();
        foreach ($category as $cat) {
            array_push($categoryIn, $cat->getId());
        }


        $sql = "SELECT DISTINCT
    LEAST(id1, id2) AS fromField,
    GREATEST(id2, id1) AS toField,
    (SELECT
            COUNT(b.id)
        FROM
            breakdown b
        WHERE
            b.closed = 1
                AND EXISTS( SELECT
                    1
                FROM
                    breakdowns_descriptors bd
                WHERE
                    b.id = bd.breakdown_id
                        AND bd.descriptor_id = id1)
                AND EXISTS( SELECT
                    1
                FROM
                    breakdowns_descriptors bd
                WHERE
                    IF(:minDuration  IS NULL AND :maxDuration  IS NULL,
                        1,
                        IF(:minDuration  IS NOT NULL AND :maxDuration  IS NOT NULL,
                            TIME_TO_SEC(TIMEDIFF(b.stop, b.start)) BETWEEN :minDuration AND :maxDuration,
                            IF(:minDuration  IS NULL AND :maxDuration  IS NOT NULL,
                                TIME_TO_SEC(TIMEDIFF(b.stop, b.start)) <= :maxDuration,
                                IF(:minDuration  IS NOT NULL AND :maxDuration  IS NULL,
                                    TIME_TO_SEC(TIMEDIFF(b.stop, b.start)) >= :minDuration,
                                    1))))

                        AND IF(:start IS NOT NULL AND :stop IS NOT NULL,
                        (b.start BETWEEN :start AND :stop)
                            OR (b.stop BETWEEN :start AND :stop),
                        IF(:start IS NULL AND :stop IS NOT NULL,
                            (b.start <= :stop) OR (b.stop <= :stop),
                            IF(:start IS NOT NULL AND :stop IS NULL,
                                (b.start >= :start)
                                    OR (b.stop >= :start),
                                (b.start >= 0))))
                        AND b.id = bd.breakdown_id
                        AND b.closed = 1
                        AND bd.descriptor_id = id2)) AS valueField
FROM
    (SELECT
        d1.id AS id1, d2.id AS id2
    FROM
        descriptor d1
    LEFT JOIN descriptor d2 ON d1.id != d2.id AND d2.category IN (:category)
    WHERE
        d1.category IN (:category)) s1
HAVING valueField > 0
ORDER BY id1;";


        $em = $this->getEntityManager();
        $rsm = new ResultSetMapping;
        $rsm->addScalarResult('fromField', 'fromField');
        $rsm->addScalarResult('toField', 'toField');
        $rsm->addScalarResult('valueField', 'valueField');

        $query = $em->createNativeQuery($sql, $rsm);

        $query->setParameter('start', $start);
        $query->setParameter('stop', $stop);
        $query->setParameter('minDuration', $minDuration);
        $query->setParameter('maxDuration', $maxDuration);
        $query->setParameter('category', $categoryIn);

        return $query->getScalarResult();
    }




    public function AnalyzerEdgesWithDoublon($category, $start = null, $stop = null, $minDuration = null, $maxDuration = null)
    {

        $categoryIn = array();
        foreach ($category as $cat) {
            array_push($categoryIn, $cat->getId());
        }


        $sql = "SELECT DISTINCT
    id1 AS fromField,
    id2 AS toField,
    (SELECT
            COUNT(b.id)
        FROM
            breakdown b
        WHERE
            b.closed = 1
                AND EXISTS( SELECT
                    1
                FROM
                    breakdowns_descriptors bd
                WHERE
                    b.id = bd.breakdown_id
                        AND bd.descriptor_id = id1)
                AND EXISTS( SELECT
                    1
                FROM
                    breakdowns_descriptors bd
                WHERE
                    IF(:minDuration  IS NULL AND :maxDuration  IS NULL,
                        1,
                        IF(:minDuration  IS NOT NULL AND :maxDuration  IS NOT NULL,
                            TIME_TO_SEC(TIMEDIFF(b.stop, b.start)) BETWEEN :minDuration AND :maxDuration,
                            IF(:minDuration  IS NULL AND :maxDuration  IS NOT NULL,
                                TIME_TO_SEC(TIMEDIFF(b.stop, b.start)) <= :maxDuration,
                                IF(:minDuration  IS NOT NULL AND :maxDuration  IS NULL,
                                    TIME_TO_SEC(TIMEDIFF(b.stop, b.start)) >= :minDuration,
                                    1))))

                        AND IF(:start IS NOT NULL AND :stop IS NOT NULL,
                        (b.start BETWEEN :start AND :stop)
                            OR (b.stop BETWEEN :start AND :stop),
                        IF(:start IS NULL AND :stop IS NOT NULL,
                            (b.start <= :stop) OR (b.stop <= :stop),
                            IF(:start IS NOT NULL AND :stop IS NULL,
                                (b.start >= :start)
                                    OR (b.stop >= :start),
                                (b.start >= 0))))
                        AND b.id = bd.breakdown_id
                        AND b.closed = 1
                        AND bd.descriptor_id = id2)) AS valueField
FROM
    (SELECT
        d1.id AS id1, d2.id AS id2
    FROM
        descriptor d1
    LEFT JOIN descriptor d2 ON d1.id != d2.id AND d2.category IN (:category)
    WHERE
        d1.category IN (:category)) s1
HAVING valueField > 0
ORDER BY id1;";


        $em = $this->getEntityManager();
        $rsm = new ResultSetMapping;
        $rsm->addScalarResult('fromField', 'fromField');
        $rsm->addScalarResult('toField', 'toField');
        $rsm->addScalarResult('valueField', 'valueField');

        $query = $em->createNativeQuery($sql, $rsm);

        $query->setParameter('start', $start);
        $query->setParameter('stop', $stop);
        $query->setParameter('minDuration', $minDuration);
        $query->setParameter('maxDuration', $maxDuration);
        $query->setParameter('category', $categoryIn);

        return $query->getScalarResult();
    }

    public function AnalyzerNodes($category, $start = null, $stop = null, $minDuration = null, $maxDuration = null)
    {


        $categoryIn = array();
        foreach ($category as $cat) {
            array_push($categoryIn, $cat->getId());
        }


        $sql = "

            SELECT
                d.id AS idField,
                d.label AS labelField,
                d.category AS categoryField,
                COUNT(b.id) AS valueField,
                group_concat(b.id) AS breakdownsField,
                b.start as start,
                b.stop as stop,
                sec_to_time(SUM((TIME_TO_SEC(TIMEDIFF(b.stop, b.start))))) as cumulativeDuration,
                round(100*SUM((TIME_TO_SEC(TIMEDIFF(b.stop, b.start)))) /  (SELECT
            SUM((TIME_TO_SEC(TIMEDIFF(b.stop, b.start))))
        FROM
            breakdown b
        WHERE
            IF(:minDuration  IS NULL AND :maxDuration  IS NULL,
                        1,
                        IF(:minDuration  IS NOT NULL AND :maxDuration  IS NOT NULL,
                            TIME_TO_SEC(TIMEDIFF(b.stop, b.start)) BETWEEN :minDuration AND :maxDuration,
                            IF(:minDuration  IS NULL AND :maxDuration  IS NOT NULL,
                                TIME_TO_SEC(TIMEDIFF(b.stop, b.start)) <= :maxDuration,
                                IF(:minDuration  IS NOT NULL AND :maxDuration  IS NULL,
                                    TIME_TO_SEC(TIMEDIFF(b.stop, b.start)) >= :minDuration,
                                    1))))

                AND IF(:start IS NOT NULL AND :stop IS NOT NULL,
                (b.start BETWEEN :start AND :stop)
                    OR (b.stop BETWEEN :start AND :stop),
                IF(:start IS NULL AND :stop IS NOT NULL,
                    (b.start <= :stop) OR (b.stop <= :stop),
                    IF(:start IS NOT NULL AND :stop IS NULL,
                        (b.start >= :start)
                            OR (b.stop >= :start),
                        (b.start >= 0))))
                AND d.category IN (:category)
                AND b.closed = 1),2) as breakdownLengthRatio
            FROM
                descriptor d
                    LEFT JOIN
                breakdowns_descriptors bd ON bd.descriptor_id = d.id
                    LEFT JOIN
                breakdown b ON b.id = bd.breakdown_id
            WHERE

            IF( :minDuration IS NOT NULL AND :maxDuration IS NOT NULL,
                    (TIME_TO_SEC(TIMEDIFF(b.stop, b.start)) BETWEEN :minDuration AND :maxDuration),
                    IF(:minDuration IS NULL AND :maxDuration IS NOT NULL,
                        (TIME_TO_SEC(TIMEDIFF(b.stop, b.start)) <= :maxDuration),
                        IF(:minDuration IS NOT NULL AND :maxDuration IS NULL,
                            (TIME_TO_SEC(TIMEDIFF(b.stop, b.start)) >= :minDuration),
                            (TIME_TO_SEC(TIMEDIFF(b.stop, b.start)) >= 0))))
            AND

            IF(:start IS NOT NULL AND :stop IS NOT NULL,(b.start BETWEEN :start AND :stop) OR (b.stop BETWEEN :start AND :stop),
                IF(:start IS NULL AND :stop IS NOT NULL, (b.stop <= :stop) ,
                    IF(:start IS NOT NULL AND :stop IS NULL,(b.start >= :start),
                        (b.start >= 0)
                    )
                )
            )
            AND d.category IN (:category)
            AND b.closed = 1
            GROUP BY d.id
            ";


        $em = $this->getEntityManager();
        $rsm = new ResultSetMapping;
        $rsm->addScalarResult('idField', 'idField');
        $rsm->addScalarResult('labelField', 'labelField');
        $rsm->addScalarResult('valueField', 'valueField');
        $rsm->addScalarResult('categoryField', 'categoryField');
        $rsm->addScalarResult('breakdownsField', 'breakdownsField');
        $rsm->addScalarResult('breakdownLengthRatio', 'breakdownLengthRatio');
        $rsm->addScalarResult('cumulativeDuration', 'cumulativeDuration');

        $query = $em->createNativeQuery($sql, $rsm);
        $query->setParameter('start', $start);
        $query->setParameter('stop', $stop);
        $query->setParameter('minDuration', $minDuration);
        $query->setParameter('maxDuration', $maxDuration);
        $query->setParameter('category', $categoryIn);

        return $query->getScalarResult();
    }


    public function AnalyzerFindAll($datas)
    {

        if( !isset($datas["maxDuration"]) || $datas["maxDuration"] == 0 ){
            $maxDuration = null;
        }else{
            $maxDuration = $datas["maxDuration"];
        }
        $categoryIn = array();
        foreach ($datas["category"] as $cat) {
            array_push($categoryIn, $cat->getId());
        }


        $sql = "
        SELECT
    dId as id,
    dLabel as label,
    bList as breakdownsList,
    tL,
    tI,
    breakdownCount as breakdownCount,
    IF(:interferoPonderation = 'on',
        ROUND(100 * (dBreakdownCount*dBreakdownInterfero/breakdownCount)/tI, 2),
        ROUND(100 * dBreakdownCount / bC, 2)) AS breakdownOccuranceRatio,
    IF(:interferoPonderation = 'on',
        ROUND(100 * (dBreakdownLength/tL)*(dBreakdownInterfero/breakdownCount)/(tI/bC),2),
        ROUND(100 * dBreakdownLength/tL, 2)) AS breakdownLengthRatio,
    IF(:timePonderation = 'off',
        IF(:interferoPonderation = 'on',ROUND(100 * (dBreakdownCount*dBreakdownInterfero/breakdownCount)/tI, 2),ROUND(100 * dBreakdownCount / bC, 2)),
        IF(:interferoPonderation = 'on',ROUND(100 * (dBreakdownLength/tL)*(dBreakdownInterfero/breakdownCount)/(tI/bC),2),ROUND(100 * dBreakdownLength/tL, 2))
    ) AS limitCriteria
FROM
    (SELECT
        dId,
            dLabel,
            COUNT(dId) breakdownCount,
            GROUP_CONCAT(bId) AS bList,
            SUM(1) AS dBreakdownCount,
            SUM(bLength) AS dBreakdownLength,
            SUM(bInterfero) AS dBreakdownInterfero,
            SUM(bLength * bInterfero) AS dBreakdownLengthInterfered,
            SUM(bInterfero) AS dBreakdownCountInterfered
    FROM
        (SELECT
        bId,
            dId,
            dLabel,
            bInterfero,
            SUM(TIME_TO_SEC(TIMEDIFF(bStop, bStart))) bLength
    FROM
        (SELECT
        b.id AS bId,
            b.start AS bStart,
            b.stop AS bStop,
            d.id AS dId,
            d.label AS dLabel,
            1 - SUM(bi.status) / COUNT(bi.id) AS bInterfero
    FROM
        breakdown b
    LEFT JOIN breakdowns_descriptors bd ON bd.breakdown_id = b.id
    LEFT JOIN descriptor d ON d.id = bd.descriptor_id
    LEFT JOIN breakdowns_interferos bi ON bi.breakdown = b.id
    WHERE
                IF(:minDuration  IS NULL AND :maxDuration  IS NULL,
                        1,
                        IF(:minDuration  IS NOT NULL AND :maxDuration  IS NOT NULL,
                            TIME_TO_SEC(TIMEDIFF(b.stop, b.start)) BETWEEN :minDuration AND :maxDuration,
                            IF(:minDuration  IS NULL AND :maxDuration  IS NOT NULL,
                                TIME_TO_SEC(TIMEDIFF(b.stop, b.start)) <= :maxDuration,
                                IF(:minDuration  IS NOT NULL AND :maxDuration  IS NULL,
                                    TIME_TO_SEC(TIMEDIFF(b.stop, b.start)) >= :minDuration,
                                    1))))

                    AND IF(:start IS NOT NULL AND :stop IS NOT NULL,
                    (b.start BETWEEN :start AND :stop)
                        OR (b.stop BETWEEN :start AND :stop),
                    IF(:start IS NULL AND :stop IS NOT NULL,
                        (b.start <= :stop) OR (b.stop <= :stop),
                        IF(:start IS NOT NULL AND :stop IS NULL,
                            (b.start >= :start)
                                OR (b.stop >= :start),
                            (b.start >= 0))))
                    AND b.closed = 1
                    AND d.category IN (:category)
    GROUP BY b.id , d.id) R1
    GROUP BY bId , dId) R2
    GROUP BY dId) R3
        JOIN
    (SELECT
        SUM(tL) AS tL, SUM(tL) / COUNT(tL) AS mL
    FROM
        (SELECT
        SUM(TIME_TO_SEC(TIMEDIFF(b.stop, b.start))) AS tL
    FROM
        breakdown b
        WHERE
                IF(:minDuration  IS NULL AND :maxDuration  IS NULL,
                        1,
                        IF(:minDuration  IS NOT NULL AND :maxDuration  IS NOT NULL,
                            TIME_TO_SEC(TIMEDIFF(b.stop, b.start)) BETWEEN :minDuration AND :maxDuration,
                            IF(:minDuration  IS NULL AND :maxDuration  IS NOT NULL,
                                TIME_TO_SEC(TIMEDIFF(b.stop, b.start)) <= :maxDuration,
                                IF(:minDuration  IS NOT NULL AND :maxDuration  IS NULL,
                                    TIME_TO_SEC(TIMEDIFF(b.stop, b.start)) >= :minDuration,
                                    1))))

                    AND IF(:start IS NOT NULL AND :stop IS NOT NULL,
                    (b.start BETWEEN :start AND :stop)
                        OR (b.stop BETWEEN :start AND :stop),
                    IF(:start IS NULL AND :stop IS NOT NULL,
                        (b.start <= :stop) OR (b.stop <= :stop),
                        IF(:start IS NOT NULL AND :stop IS NULL,
                            (b.start >= :start)
                                OR (b.stop >= :start),
                            (b.start >= 0))))
                    AND b.closed = 1
    GROUP BY b.id) RL) RL2
        JOIN
    (SELECT
        SUM(tI) AS tI, SUM(tI) / COUNT(tI) AS mI
    FROM
        (SELECT
        1 - SUM(bi.status) / COUNT(bi.id) AS tI
    FROM
        breakdown b
    LEFT JOIN breakdowns_interferos bi ON bi.breakdown = b.id
    WHERE
                IF(:minDuration  IS NULL AND :maxDuration  IS NULL,
                        1,
                        IF(:minDuration  IS NOT NULL AND :maxDuration  IS NOT NULL,
                            TIME_TO_SEC(TIMEDIFF(b.stop, b.start)) BETWEEN :minDuration AND :maxDuration,
                            IF(:minDuration  IS NULL AND :maxDuration  IS NOT NULL,
                                TIME_TO_SEC(TIMEDIFF(b.stop, b.start)) <= :maxDuration,
                                IF(:minDuration  IS NOT NULL AND :maxDuration  IS NULL,
                                    TIME_TO_SEC(TIMEDIFF(b.stop, b.start)) >= :minDuration,
                                    1))))

                    AND IF(:start IS NOT NULL AND :stop IS NOT NULL,
                    (b.start BETWEEN :start AND :stop)
                        OR (b.stop BETWEEN :start AND :stop),
                    IF(:start IS NULL AND :stop IS NOT NULL,
                        (b.start <= :stop) OR (b.stop <= :stop),
                        IF(:start IS NOT NULL AND :stop IS NULL,
                            (b.start >= :start)
                                OR (b.stop >= :start),
                            (b.start >= 0))))
                    AND b.closed = 1
    GROUP BY b.id) RI) RI2
        JOIN
    (SELECT
        COUNT(b.id) AS bC
    FROM
        breakdown b
    WHERE
                IF(:minDuration  IS NULL AND :maxDuration  IS NULL,
                        1,
                        IF(:minDuration  IS NOT NULL AND :maxDuration  IS NOT NULL,
                            TIME_TO_SEC(TIMEDIFF(b.stop, b.start)) BETWEEN :minDuration AND :maxDuration,
                            IF(:minDuration  IS NULL AND :maxDuration  IS NOT NULL,
                                TIME_TO_SEC(TIMEDIFF(b.stop, b.start)) <= :maxDuration,
                                IF(:minDuration  IS NOT NULL AND :maxDuration  IS NULL,
                                    TIME_TO_SEC(TIMEDIFF(b.stop, b.start)) >= :minDuration,
                                    1))))

                    AND IF(:start IS NOT NULL AND :stop IS NOT NULL,
                    (b.start BETWEEN :start AND :stop)
                        OR (b.stop BETWEEN :start AND :stop),
                    IF(:start IS NULL AND :stop IS NOT NULL,
                        (b.start <= :stop) OR (b.stop <= :stop),
                        IF(:start IS NOT NULL AND :stop IS NULL,
                            (b.start >= :start)
                                OR (b.stop >= :start),
                            (b.start >= 0))))
                    AND b.closed = 1
        ) RB
HAVING limitCriteria BETWEEN :minLimit AND :maxLimit
ORDER BY IF(:timePonderation = 'on',
    breakdownLengthRatio,
    breakdownOccuranceRatio) DESC
;


        ";

        $em = $this->getEntityManager();
        $rsm = new ResultSetMapping;
        $rsm->addScalarResult('id', 'id');
        $rsm->addScalarResult('label', 'label');
        $rsm->addScalarResult('breakdownLengthRatio', 'breakdownLengthRatio');
        $rsm->addScalarResult('breakdownsList', 'breakdownsList');
        $rsm->addScalarResult('breakdownCount', 'breakdownCount');
        $rsm->addScalarResult('breakdownOccuranceRatio', 'breakdownOccuranceRatio');
        $query = $em->createNativeQuery($sql, $rsm);
        $query->setParameter('timePonderation', $datas['timePonderation']);
        $query->setParameter('interferoPonderation', $datas['interferoPonderation']);
        $query->setParameter('start', $datas['start']);
        $query->setParameter('stop', $datas['stop']);
        $query->setParameter('minDuration', $datas['minDuration']);
        $query->setParameter('maxDuration', $maxDuration);
        $query->setParameter('minLimit', $datas['minLimit']);
        $query->setParameter('maxLimit', $datas['maxLimit']);
        $query->setParameter('category', $categoryIn);
        return $query->getScalarResult();
    }

    public function ManagerNodes($descriptor)
    {
    $sql = "

SELECT count(label) as valueField,label as labelField,d1.category as categoryField,d1.id as idField,d1.category as categoryField  FROM breakdown b1
LEFT JOIN breakdowns_descriptors bd1 ON bd1.breakdown_id = b1.id
LEFT JOIN descriptor d1 ON bd1.descriptor_id = d1.id
WHERE   b1.id IN (
SELECT
    breakdown_id
FROM
    (SELECT
        b.id AS breakdown_id, d.label AS label, d.id
    FROM
        breakdown b
    LEFT JOIN breakdowns_descriptors bd ON bd.breakdown_id = b.id
    LEFT JOIN descriptor d ON bd.descriptor_id = d.id
    HAVING d.id = :descriptor_id) findBreakdowns
    )
group by d1.id
";
         $em = $this->getEntityManager();
        $rsm = new ResultSetMapping;
        $rsm->addScalarResult('idField', 'idField');
        $rsm->addScalarResult('labelField', 'labelField');
        $rsm->addScalarResult('valueField', 'valueField');
        $rsm->addScalarResult('categoryField', 'categoryField');

        $query = $em->createNativeQuery($sql, $rsm);


        $query->setParameter('descriptor_id', $descriptor->getId());

        return $query->getScalarResult();
    }
    public function ManagerEdges($descriptor)
    {
    $sql = "SELECT DISTINCT
        LEAST(id1, id2) AS fromField,
        GREATEST(id2, id1) AS toField,
        (SELECT
                COUNT(b.id)
            FROM
                breakdown b
            WHERE

                b.id IN (
                SELECT
            b.id AS breakdown_id
        FROM
            breakdown b
        LEFT JOIN breakdowns_descriptors bd ON bd.breakdown_id = b.id
        LEFT JOIN descriptor d ON bd.descriptor_id = d.id
        WHERE d.id = :descriptor_id)

                    AND EXISTS( SELECT
                        1
                    FROM
                        breakdowns_descriptors bd
                    WHERE
                        b.id = bd.breakdown_id
                            AND bd.descriptor_id = id1)
                    AND EXISTS( SELECT
                        1
                    FROM
                        breakdowns_descriptors bd
                    WHERE
                             b.id = bd.breakdown_id
                            AND bd.descriptor_id = id2)) AS valueField
    FROM
        (SELECT
            d1.id AS id1, d2.id AS id2
        FROM
            descriptor d1
        LEFT JOIN descriptor d2 ON d1.id != d2.id) s1
    HAVING valueField > 0
    ORDER BY id1;";

        $em = $this->getEntityManager();
        $rsm = new ResultSetMapping;
        $rsm->addScalarResult('fromField', 'fromField');
        $rsm->addScalarResult('toField', 'toField');
        $rsm->addScalarResult('valueField', 'valueField');

        $query = $em->createNativeQuery($sql, $rsm);

        $query->setParameter('descriptor_id', $descriptor->getId());

        return $query->getScalarResult();
    }
}
