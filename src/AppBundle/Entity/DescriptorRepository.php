<?php

namespace AppBundle\Entity;
use AppBundle\AppBundle;
use Doctrine\ORM\Query\ResultSetMapping;
/**
 * DescriptorRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class DescriptorRepository extends \Doctrine\ORM\EntityRepository
{
    public function findByLabelAndCategoryWithSynonym($label, $category)
    {
        $sql = "

       SELECT
       DISTINCT(id),
       label,
       (SELECT color from descriptor_category WHERE id = category) as color,
       category,count(DISTINCT(bd.breakdown_id)) as breakdownCount

        FROM (
                SELECT d.id as id , d.label as label , d.category as category , NULL as syn FROM descriptor d WHERE d.label LIKE :label
                UNION ALL
                SELECT s.descriptor as id, (SELECT label FROM descriptor WHERE id=s.descriptor) as label , (SELECT category FROM descriptor WHERE id=s.descriptor) as category , s.label as syn   FROM synonym s WHERE s.label LIKE :label
            ) tot
            LEFT JOIN
            breakdowns_descriptors as bd ON bd.descriptor_id=tot.id


            GROUP BY tot.id
            HAVING breakdownCount >= 0 AND category = :category
            ORDER BY breakdownCount DESC
        ";
        $em = $this->getEntityManager();
        $rsm = new ResultSetMapping;
        $rsm->addScalarResult('id', 'id');
        $rsm->addScalarResult('label', 'label');
        $rsm->addScalarResult('color', 'color');
        $query = $em->createNativeQuery($sql, $rsm);
        $query->setParameter('label', "$label");
        $query->setParameter('category', $category);
        return $query->getScalarResult();
    }

    public function findOneByLabelAndCategoryWithSynonym($label, $category)
    {

        $sql = "SELECT DISTINCT(id),label,category,count(DISTINCT(bd.breakdown_id)) as breakdownCount FROM (
                SELECT d.id as id , d.label as label , d.category as category , NULL as syn FROM descriptor d WHERE d.label LIKE :label
                UNION ALL
                SELECT s.descriptor as id, (SELECT label FROM descriptor WHERE id=s.descriptor) as label , (SELECT category FROM descriptor WHERE id=s.descriptor) as category , s.label as syn   FROM synonym s WHERE s.label LIKE :label
            ) tot
            LEFT JOIN
            breakdowns_descriptors as bd ON bd.descriptor_id=tot.id


            GROUP BY tot.id
            HAVING breakdownCount > 0 AND category = :category
            ORDER BY breakdownCount DESC
                ";


        $em = $this->getEntityManager();
        $rsm = new ResultSetMapping;
        $rsm->addScalarResult('id', 'id');
        $rsm->addScalarResult('label', 'label');
        $query = $em->createNativeQuery($sql, $rsm);
        $query->setParameter('label', "$label");
        $query->setParameter('category', $category);
        return $query->getScalarResult();
    }

    public function findOneByLabelAndCategory($label, $category)
    {

        $sql = "SELECT
                    *
                    FROM descriptor
                WHERE label LIKE :label AND category = $category

                ";


        $em = $this->getEntityManager();
        $rsm = new ResultSetMapping;
        $rsm->addScalarResult('id', 'id');
        $rsm->addScalarResult('label', 'label');
        $rsm->addScalarResult('color', 'color');
        $query = $em->createNativeQuery($sql, $rsm);
        $query->setParameter('label', "$label");
        $query->setParameter('category', $category);
        return $query->getScalarResult();
    }

    public function AnalyzerEdges($category, $start = null, $stop = null, $minDuration = null, $maxDuration = null)
    {

        $categoryIn = array();
        foreach ($category as $cat) {
            array_push($categoryIn, $cat->getId());
        }


        $sql = "SELECT DISTINCT
    LEAST(id1, id2) AS fromField,
    GREATEST(id2, id1) AS toField,
    (SELECT
            COUNT(b.id)
        FROM
            breakdown b
        WHERE
            b.closed = 1
                AND EXISTS( SELECT
                    1
                FROM
                    breakdowns_descriptors bd
                WHERE
                    b.id = bd.breakdown_id
                        AND bd.descriptor_id = id1)
                AND EXISTS( SELECT
                    1
                FROM
                    breakdowns_descriptors bd
                WHERE
                    IF(:minDuration  IS NULL AND :maxDuration  IS NULL,
                        1,
                        IF(:minDuration  IS NOT NULL AND :maxDuration  IS NOT NULL,
                            TIME_TO_SEC(TIMEDIFF(b.stop, b.start)) BETWEEN :minDuration AND :maxDuration,
                            IF(:minDuration  IS NULL AND :maxDuration  IS NOT NULL,
                                TIME_TO_SEC(TIMEDIFF(b.stop, b.start)) <= :maxDuration,
                                IF(:minDuration  IS NOT NULL AND :maxDuration  IS NULL,
                                    TIME_TO_SEC(TIMEDIFF(b.stop, b.start)) >= :minDuration,
                                    1))))

                        AND IF(:start IS NOT NULL AND :stop IS NOT NULL,
                        (b.start BETWEEN :start AND :stop)
                            OR (b.stop BETWEEN :start AND :stop),
                        IF(:start IS NULL AND :stop IS NOT NULL,
                            (b.start <= :stop) OR (b.stop <= :stop),
                            IF(:start IS NOT NULL AND :stop IS NULL,
                                (b.start >= :start)
                                    OR (b.stop >= :start),
                                (b.start >= 0))))
                        AND b.id = bd.breakdown_id
                        AND b.closed = 1
                        AND bd.descriptor_id = id2)) AS valueField
FROM
    (SELECT
        d1.id AS id1, d2.id AS id2
    FROM
        descriptor d1
    LEFT JOIN descriptor d2 ON d1.id != d2.id AND d2.category IN (:category)
    WHERE
        d1.category IN (:category)) s1
HAVING valueField > 0
ORDER BY id1;";


        $em = $this->getEntityManager();
        $rsm = new ResultSetMapping;
        $rsm->addScalarResult('fromField', 'fromField');
        $rsm->addScalarResult('toField', 'toField');
        $rsm->addScalarResult('valueField', 'valueField');

        $query = $em->createNativeQuery($sql, $rsm);

        $query->setParameter('start', $start);
        $query->setParameter('stop', $stop);
        $query->setParameter('minDuration', $minDuration);
        $query->setParameter('maxDuration', $maxDuration);
        $query->setParameter('category', $categoryIn);

        return $query->getScalarResult();
    }




    public function AnalyzerEdgesWithDoublon($category, $start = null, $stop = null, $minDuration = null, $maxDuration = null)
    {

        $categoryIn = array();
        foreach ($category as $cat) {
            array_push($categoryIn, $cat->getId());
        }


        $sql = "SELECT DISTINCT
    id1 AS fromField,
    id2 AS toField,
    (SELECT
            COUNT(b.id)
        FROM
            breakdown b
        WHERE
            b.closed = 1
                AND EXISTS( SELECT
                    1
                FROM
                    breakdowns_descriptors bd
                WHERE
                    b.id = bd.breakdown_id
                        AND bd.descriptor_id = id1)
                AND EXISTS( SELECT
                    1
                FROM
                    breakdowns_descriptors bd
                WHERE
                    IF(:minDuration  IS NULL AND :maxDuration  IS NULL,
                        1,
                        IF(:minDuration  IS NOT NULL AND :maxDuration  IS NOT NULL,
                            TIME_TO_SEC(TIMEDIFF(b.stop, b.start)) BETWEEN :minDuration AND :maxDuration,
                            IF(:minDuration  IS NULL AND :maxDuration  IS NOT NULL,
                                TIME_TO_SEC(TIMEDIFF(b.stop, b.start)) <= :maxDuration,
                                IF(:minDuration  IS NOT NULL AND :maxDuration  IS NULL,
                                    TIME_TO_SEC(TIMEDIFF(b.stop, b.start)) >= :minDuration,
                                    1))))

                        AND IF(:start IS NOT NULL AND :stop IS NOT NULL,
                        (b.start BETWEEN :start AND :stop)
                            OR (b.stop BETWEEN :start AND :stop),
                        IF(:start IS NULL AND :stop IS NOT NULL,
                            (b.start <= :stop) OR (b.stop <= :stop),
                            IF(:start IS NOT NULL AND :stop IS NULL,
                                (b.start >= :start)
                                    OR (b.stop >= :start),
                                (b.start >= 0))))
                        AND b.id = bd.breakdown_id
                        AND b.closed = 1
                        AND bd.descriptor_id = id2)) AS valueField
FROM
    (SELECT
        d1.id AS id1, d2.id AS id2
    FROM
        descriptor d1
    LEFT JOIN descriptor d2 ON d1.id != d2.id AND d2.category IN (:category)
    WHERE
        d1.category IN (:category)) s1
HAVING valueField > 0
ORDER BY id1;";


        $em = $this->getEntityManager();
        $rsm = new ResultSetMapping;
        $rsm->addScalarResult('fromField', 'fromField');
        $rsm->addScalarResult('toField', 'toField');
        $rsm->addScalarResult('valueField', 'valueField');

        $query = $em->createNativeQuery($sql, $rsm);

        $query->setParameter('start', $start);
        $query->setParameter('stop', $stop);
        $query->setParameter('minDuration', $minDuration);
        $query->setParameter('maxDuration', $maxDuration);
        $query->setParameter('category', $categoryIn);

        return $query->getScalarResult();
    }

    public function AnalyzerNodes($category, $start = null, $stop = null, $minDuration = null, $maxDuration = null)
    {


        $categoryIn = array();
        foreach ($category as $cat) {
            array_push($categoryIn, $cat->getId());
        }


        $sql = "

            SELECT
                d.id AS idField,
                d.label AS labelField,
                d.category AS categoryField,
                COUNT(b.id) AS valueField,
                group_concat(b.id) AS breakdownsField,
                b.start as start,
                b.stop as stop,
                sec_to_time(SUM((TIME_TO_SEC(TIMEDIFF(b.stop, b.start))))) as cumulativeDuration,
                round(100*SUM((TIME_TO_SEC(TIMEDIFF(b.stop, b.start)))) /  (SELECT
            SUM((TIME_TO_SEC(TIMEDIFF(b.stop, b.start))))
        FROM
            breakdown b
        WHERE
            IF(:minDuration  IS NULL AND :maxDuration  IS NULL,
                        1,
                        IF(:minDuration  IS NOT NULL AND :maxDuration  IS NOT NULL,
                            TIME_TO_SEC(TIMEDIFF(b.stop, b.start)) BETWEEN :minDuration AND :maxDuration,
                            IF(:minDuration  IS NULL AND :maxDuration  IS NOT NULL,
                                TIME_TO_SEC(TIMEDIFF(b.stop, b.start)) <= :maxDuration,
                                IF(:minDuration  IS NOT NULL AND :maxDuration  IS NULL,
                                    TIME_TO_SEC(TIMEDIFF(b.stop, b.start)) >= :minDuration,
                                    1))))

                AND IF(:start IS NOT NULL AND :stop IS NOT NULL,
                (b.start BETWEEN :start AND :stop)
                    OR (b.stop BETWEEN :start AND :stop),
                IF(:start IS NULL AND :stop IS NOT NULL,
                    (b.start <= :stop) OR (b.stop <= :stop),
                    IF(:start IS NOT NULL AND :stop IS NULL,
                        (b.start >= :start)
                            OR (b.stop >= :start),
                        (b.start >= 0))))
                AND d.category IN (:category)
                AND b.closed = 1),2) as breakdownLengthRatio
            FROM
                descriptor d
                    LEFT JOIN
                breakdowns_descriptors bd ON bd.descriptor_id = d.id
                    LEFT JOIN
                breakdown b ON b.id = bd.breakdown_id
            WHERE

            IF( :minDuration IS NOT NULL AND :maxDuration IS NOT NULL,
                    (TIME_TO_SEC(TIMEDIFF(b.stop, b.start)) BETWEEN :minDuration AND :maxDuration),
                    IF(:minDuration IS NULL AND :maxDuration IS NOT NULL,
                        (TIME_TO_SEC(TIMEDIFF(b.stop, b.start)) <= :maxDuration),
                        IF(:minDuration IS NOT NULL AND :maxDuration IS NULL,
                            (TIME_TO_SEC(TIMEDIFF(b.stop, b.start)) >= :minDuration),
                            (TIME_TO_SEC(TIMEDIFF(b.stop, b.start)) >= 0))))
            AND

            IF(:start IS NOT NULL AND :stop IS NOT NULL,(b.start BETWEEN :start AND :stop) OR (b.stop BETWEEN :start AND :stop),
                IF(:start IS NULL AND :stop IS NOT NULL, (b.stop <= :stop) ,
                    IF(:start IS NOT NULL AND :stop IS NULL,(b.start >= :start),
                        (b.start >= 0)
                    )
                )
            )
            AND d.category IN (:category)
            AND b.closed = 1
            GROUP BY d.id
            ";


        $em = $this->getEntityManager();
        $rsm = new ResultSetMapping;
        $rsm->addScalarResult('idField', 'idField');
        $rsm->addScalarResult('labelField', 'labelField');
        $rsm->addScalarResult('valueField', 'valueField');
        $rsm->addScalarResult('categoryField', 'categoryField');
        $rsm->addScalarResult('breakdownsField', 'breakdownsField');
        $rsm->addScalarResult('breakdownLengthRatio', 'breakdownLengthRatio');
        $rsm->addScalarResult('cumulativeDuration', 'cumulativeDuration');

        $query = $em->createNativeQuery($sql, $rsm);
        $query->setParameter('start', $start);
        $query->setParameter('stop', $stop);
        $query->setParameter('minDuration', $minDuration);
        $query->setParameter('maxDuration', $maxDuration);
        $query->setParameter('category', $categoryIn);

        return $query->getScalarResult();
    }


    public function AnalyzerFindAll($category, $start = null, $stop = null, $minDuration = null, $maxDuration = null,$interferoPonderation=0,$timePonderation="occurance")
    {
        if($maxDuration == 0){
            $maxDuration = null;
        }
        $categoryIn = array();
        foreach ($category as $cat) {
            array_push($categoryIn, $cat->getId());
        }



        $sql = "SELECT
    descriptorId AS id,
    descriptorLabel AS label,
    descriptorCategory AS category_id,
    GROUP_CONCAT(breakdownId) as breakdownsList ,
    GROUP_CONCAT(breakdownId,'|',lengthRatio,'|',breakdownInterferoRatio) as breakdownsInfo ,

    COUNT(breakdownId) AS breakdownCount,


    IF( :interferoPonderation = 'on' , round(100*COUNT(breakdownId*breakdownInterferoRatio)/tot,2) , round(100*COUNT(breakdownId)/tot,2) ) AS breakdownOccuranceRatio,
    IF( :interferoPonderation = 'on' , round(100*SUM(lengthRatio*breakdownInterferoRatio),2)  , round(100*SUM(lengthRatio),2) ) AS breakdownLengthRatio,




    GROUP_CONCAT(breakdownInterferoRatio) as breakdownsField ,
    SUM(breakdownInterferoRatio) as breakdownInterferoRatio
FROM
    (SELECT
			b.id AS breakdownId,
            d.id AS descriptorId,
            d.label AS descriptorLabel,
            d.category AS descriptorCategory,
            1 - SUM(bi.status) / COUNT(bi.id) AS breakdownInterferoRatio,
            (SELECT
                    COUNT(id)
                FROM
                    breakdown b

                WHERE
                IF(:minDuration  IS NULL AND :maxDuration  IS NULL,
                        1,
                        IF(:minDuration  IS NOT NULL AND :maxDuration  IS NOT NULL,
                            TIME_TO_SEC(TIMEDIFF(b.stop, b.start)) BETWEEN :minDuration AND :maxDuration,
                            IF(:minDuration  IS NULL AND :maxDuration  IS NOT NULL,
                                TIME_TO_SEC(TIMEDIFF(b.stop, b.start)) <= :maxDuration,
                                IF(:minDuration  IS NOT NULL AND :maxDuration  IS NULL,
                                    TIME_TO_SEC(TIMEDIFF(b.stop, b.start)) >= :minDuration,
                                    1))))

                    AND IF(:start IS NOT NULL AND :stop IS NOT NULL,
                    (b.start BETWEEN :start AND :stop)
                        OR (b.stop BETWEEN :start AND :stop),
                    IF(:start IS NULL AND :stop IS NOT NULL,
                        (b.start <= :stop) OR (b.stop <= :stop),
                        IF(:start IS NOT NULL AND :stop IS NULL,
                            (b.start >= :start)
                                OR (b.stop >= :start),
                            (b.start >= 0))))
                    AND d.category IN (:category)
                    AND b.closed = 1

                    ) AS tot,
            TIME_TO_SEC(TIMEDIFF(b.stop, b.start)) / (SELECT
                    SUM(TIME_TO_SEC(TIMEDIFF(stop, start)))
                FROM
                    breakdown b
                WHERE
                IF(:minDuration  IS NULL AND :maxDuration  IS NULL,
                        1,
                        IF(:minDuration  IS NOT NULL AND :maxDuration  IS NOT NULL,
                            TIME_TO_SEC(TIMEDIFF(b.stop, b.start)) BETWEEN :minDuration AND :maxDuration,
                            IF(:minDuration  IS NULL AND :maxDuration  IS NOT NULL,
                                TIME_TO_SEC(TIMEDIFF(b.stop, b.start)) <= :maxDuration,
                                IF(:minDuration  IS NOT NULL AND :maxDuration  IS NULL,
                                    TIME_TO_SEC(TIMEDIFF(b.stop, b.start)) >= :minDuration,
                                    1))))

                    AND IF(:start IS NOT NULL AND :stop IS NOT NULL,
                    (b.start BETWEEN :start AND :stop)
                        OR (b.stop BETWEEN :start AND :stop),
                    IF(:start IS NULL AND :stop IS NOT NULL,
                        (b.start <= :stop) OR (b.stop <= :stop),
                        IF(:start IS NOT NULL AND :stop IS NULL,
                            (b.start >= :start)
                                OR (b.stop >= :start),
                            (b.start >= 0))))
                    AND d.category IN (:category)
                    AND b.closed = 1


                    ) AS lengthRatio,
            d.label
    FROM
        breakdown b


    LEFT JOIN breakdowns_interferos bi ON bi.breakdown = b.id
    LEFT JOIN breakdowns_descriptors bd ON bd.breakdown_id = b.id
    LEFT JOIN descriptor d ON bd.descriptor_id = d.id

	WHERE
                IF(:minDuration  IS NULL AND :maxDuration  IS NULL,
                        1,
                        IF(:minDuration  IS NOT NULL AND :maxDuration  IS NOT NULL,
                            TIME_TO_SEC(TIMEDIFF(b.stop, b.start)) BETWEEN :minDuration AND :maxDuration,
                            IF(:minDuration  IS NULL AND :maxDuration  IS NOT NULL,
                                TIME_TO_SEC(TIMEDIFF(b.stop, b.start)) <= :maxDuration,
                                IF(:minDuration  IS NOT NULL AND :maxDuration  IS NULL,
                                    TIME_TO_SEC(TIMEDIFF(b.stop, b.start)) >= :minDuration,
                                    1))))

                    AND IF(:start IS NOT NULL AND :stop IS NOT NULL,
                    (b.start BETWEEN :start AND :stop)
                        OR (b.stop BETWEEN :start AND :stop),
                    IF(:start IS NULL AND :stop IS NOT NULL,
                        (b.start <= :stop) OR (b.stop <= :stop),
                        IF(:start IS NOT NULL AND :stop IS NULL,
                            (b.start >= :start)
                                OR (b.stop >= :start),
                            (b.start >= 0))))
                    AND d.category IN (:category)
                    AND b.closed = 1

    GROUP BY b.id , d.id) R1
GROUP BY descriptorId

ORDER BY  IF( :timePonderation = 'on' ,
    IF( :interferoPonderation = 'on' , SUM(lengthRatio*breakdownInterferoRatio)  , SUM(lengthRatio) ) ,
    IF( :interferoPonderation = 'on'  , COUNT(breakdownId*breakdownInterferoRatio)/tot , COUNT(breakdownId)/tot )
    ) DESC
";



        $em = $this->getEntityManager();
        $rsm = new ResultSetMapping;
        $rsm->addScalarResult('id', 'id');
        $rsm->addScalarResult('label', 'label');
        $rsm->addScalarResult('breakdownLengthRatio', 'breakdownLengthRatio');
        $rsm->addScalarResult('breakdownsList', 'breakdownsList');
        $rsm->addScalarResult('breakdownCount', 'breakdownCount');
        $rsm->addScalarResult('breakdownOccuranceRatio', 'breakdownOccuranceRatio');
        $query = $em->createNativeQuery($sql, $rsm);
        $query->setParameter('timePonderation', $timePonderation);
        $query->setParameter('interferoPonderation', $interferoPonderation);
        $query->setParameter('start', $start);
        $query->setParameter('stop', $stop);
        $query->setParameter('minDuration', $minDuration);
        $query->setParameter('maxDuration', $maxDuration);
        $query->setParameter('category', $categoryIn);
        return $query->getScalarResult();
    }

    public function ManagerNodes($descriptor)
    {
    $sql = "

SELECT count(label) as valueField,label as labelField,d1.category as categoryField,d1.id as idField,d1.category as categoryField  FROM breakdown b1
LEFT JOIN breakdowns_descriptors bd1 ON bd1.breakdown_id = b1.id
LEFT JOIN descriptor d1 ON bd1.descriptor_id = d1.id
WHERE   b1.id IN (
SELECT
    breakdown_id
FROM
    (SELECT
        b.id AS breakdown_id, d.label AS label, d.id
    FROM
        breakdown b
    LEFT JOIN breakdowns_descriptors bd ON bd.breakdown_id = b.id
    LEFT JOIN descriptor d ON bd.descriptor_id = d.id
    HAVING d.id = :descriptor_id) findBreakdowns
    )
group by d1.id
";
         $em = $this->getEntityManager();
        $rsm = new ResultSetMapping;
        $rsm->addScalarResult('idField', 'idField');
        $rsm->addScalarResult('labelField', 'labelField');
        $rsm->addScalarResult('valueField', 'valueField');
        $rsm->addScalarResult('categoryField', 'categoryField');

        $query = $em->createNativeQuery($sql, $rsm);


        $query->setParameter('descriptor_id', $descriptor->getId());

        return $query->getScalarResult();
    }
    public function ManagerEdges($descriptor)
    {
    $sql = "SELECT DISTINCT
        LEAST(id1, id2) AS fromField,
        GREATEST(id2, id1) AS toField,
        (SELECT
                COUNT(b.id)
            FROM
                breakdown b
            WHERE

                b.id IN (
                SELECT
            b.id AS breakdown_id
        FROM
            breakdown b
        LEFT JOIN breakdowns_descriptors bd ON bd.breakdown_id = b.id
        LEFT JOIN descriptor d ON bd.descriptor_id = d.id
        WHERE d.id = :descriptor_id)

                    AND EXISTS( SELECT
                        1
                    FROM
                        breakdowns_descriptors bd
                    WHERE
                        b.id = bd.breakdown_id
                            AND bd.descriptor_id = id1)
                    AND EXISTS( SELECT
                        1
                    FROM
                        breakdowns_descriptors bd
                    WHERE
                             b.id = bd.breakdown_id
                            AND bd.descriptor_id = id2)) AS valueField
    FROM
        (SELECT
            d1.id AS id1, d2.id AS id2
        FROM
            descriptor d1
        LEFT JOIN descriptor d2 ON d1.id != d2.id) s1
    HAVING valueField > 0
    ORDER BY id1;";

        $em = $this->getEntityManager();
        $rsm = new ResultSetMapping;
        $rsm->addScalarResult('fromField', 'fromField');
        $rsm->addScalarResult('toField', 'toField');
        $rsm->addScalarResult('valueField', 'valueField');

        $query = $em->createNativeQuery($sql, $rsm);

        $query->setParameter('descriptor_id', $descriptor->getId());

        return $query->getScalarResult();
    }
}
